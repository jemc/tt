#!/usr/bin/bash

# Associative array of default options
declare -A default_opts
default_opts["refresh_time"]=0.2
default_opts["format_duration"]="%H:%M:%S"
default_opts["format_time"]="%H:%M:%S"
default_opts["format_date"]="%a %b %d %Y"
default_opts["format_entry"]=$"  \${duration} | \${last_date} | \${last_time} - \${curr_time}"

# Associative array of operational options - start by copying all defaults
declare -A opts=()
for key in "${!default_opts[@]}"; do
  opts["$key"]="${default_opts["$key"]}"
done

entries=(\
)

file=$1
file_dir=$(dirname $file)

mkdir -p $file_dir
touch $file

# TODO: add warning about eval that shows the first time the program runs
# eval $file

# TODO use getopts for other actions
# insert an arbitrary message as an entry with (-m)
# specify a different output file than input file (-o)
# specify a different output format than input format (-f)


function update_time {
  curr_date=$(date +"${opts['format_date']}")
  curr_time=$(date +"${opts['format_time']}")
  curr_secs=$(date +"%s")
}

function start_entry {
  update_time
  last_date=$curr_date
  last_time=$curr_time
  last_secs=$curr_secs
  entries[${#entries[@]}]=""
  update_curr_entry
}

function update_curr_entry {
  update_time
  duration=$(date -u -d @"$((curr_secs-last_secs))" +"${opts['format_duration']}")
  eval "curr_entry=\"${opts['format_entry']}\""
  entries[${#entries[@]}-1]="${curr_entry}"
}

function show_curr_entry {
  echo "${curr_entry}"
}

function do_over {
  echo -ne "\033[1A"
}


function read_file {
  # regexp_simple="A"
  regexp_var="^\s*([A-Za-z_]+)\s*=\s*\"(.*)\"\s*$"

  while IFS= read -r line; do
    # printf '%s\n' "$line"
    if [[ $line =~ $regexp_var ]]; then
      opts["${BASH_REMATCH[1]}"]=$"${BASH_REMATCH[2]}"
    fi
  done < "$file"
}

function save_file {
  
  sh -c "cat > ${file}" <<MYEOF

refresh_time="${opts["refresh_time"]}"

format_duration="${opts["format_duration"]}"
format_time="${opts['format_time']}"
format_date="${opts['format_date']}"
format_entry="${opts['format_entry']}"

entries:
$(
for entry in "${entries[@]}"; do
  echo "${entry}"
done
)
MYEOF

}

function trap_func {
  echo
  echo 'saving...'
  save_file
  echo 'saved!'
  exit 0
}
trap trap_func SIGINT SIGTERM


read_file

for entry in "${entries[@]}"; do
  echo "${entry}"
done

start_entry
show_curr_entry

while true; do
  update_curr_entry
  do_over
  show_curr_entry
  sleep "${opts['refresh_time']}"
done
