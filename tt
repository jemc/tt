#!/usr/bin/bash

# Associative array of default options
declare -A default_opts
default_opts["refresh_time"]=0.2
default_opts["format_duration"]="%H:%M:%S"
default_opts["format_time"]="%H:%M:%S"
default_opts["format_date"]="%a %b %d %Y"
default_opts["format_entry"]=$"  %{duration} | %{last_date} | %{last_time} - %{curr_time}"

# Associative array of operational options
#  Start by copying all defaults
declare -A opts=()
for key in "${!default_opts[@]}"; do
  opts["$key"]="${default_opts["$key"]}"
done

# Associative array of state variables
#   Each is able to be interpolated into format strings
declare -A state

# Indexed array of entries
#   Each line in entries section of file is interpreted as an entry
declare -a entries=()


function usage {
  echo 'bad form.. better luck next time!'
  exit 1
}

function parse_opts {
  while getopts “:x” OPTION; do
    case "${OPTION}" in
      
      x) echo 'x received; never mind!'; exit 0;;
      
    esac
  done
}

function parse_arguments {
  
  # Note that the getopts loop is happening twice here...
  # This construction is used allow the mandatory 'file' path arg
  #   to be placed before, after or during the opt args parsed by getopts
  
  parse_opts $@ # Run getopts in a loop, stopping at the first non-option arg
  shift $((OPTIND-1)) # Shift args to put the arg rejected by getopts in $1

  state['file']=$1 # Save the rejected arg as the file path

  shift 1; OPTIND=1 # Shift args past the rejected arg and reset OPTIND
  
  second_pass=true
  parse_opts $@ # Run again, picking up any other options
  shift $((OPTIND-1)) # Shift args past the second pass of scanned opts
  
  [[ -z $@ ]] || usage # Bad args if $@ is not empty at this point
  
  # Process and verify state and option variables here
}

parse_arguments $@

state['file_dir']=$(dirname ${state['file']})
state['file_name']=$(basename ${state['file']})

mkdir -p "${state['file_dir']}"
touch "${state['file']}"


# TODO: Don't destroy other random stuff in file header

# TODO use getopts for other actions
# add a note to the new entry (-n)
# insert an arbitrary message as an entry with (-e)
# specify a different output file than input file (-o)
# specify a different output format than input format (-f)


function update_time {
  state['curr_date']=$(date +"${opts['format_date']}")
  state['curr_time']=$(date +"${opts['format_time']}")
  state['curr_secs']=$(date +"%s")
}

function start_entry {
  update_time
  state['last_date']="${state['curr_date']}"
  state['last_time']="${state['curr_time']}"
  state['last_secs']="${state['curr_secs']}"
  entries[${#entries[@]}]=""
  update_curr_entry
}

function update_curr_entry {
  update_time
  state['duration']=$(date -u -d @"$((state['curr_secs']-state['last_secs']))" +"${opts['format_duration']}")
  
  curr_entry="${opts['format_entry']}"
  for key in "${!state[@]}"; do
    curr_entry="${curr_entry/\%\{$key\}/${state[$key]}}"
  done
  
  entries[${#entries[@]}-1]="${curr_entry}"
}

function show_curr_entry {
  echo "${curr_entry}"
}

function do_over {
  echo -ne "\033[1A"
}


function read_file {
  local regexp_option="^([A-Za-z_]+)=\"(.*)\"$"
  local regexp_entries_header="^entries:$"
  local entry_mode=""
  
  while IFS= read -r line; do
    
    if [[ $entry_mode ]]
      then # Read the line in as an entry
      entries[${#entries[@]}]="${line}"
    
    elif [[ $line =~ $regexp_entries_header ]]
      then # Recognize the entries header and begin entry mode
      entry_mode=true
    
    elif [[ $line =~ $regexp_option ]]
      then # Recognize the line as an option declaration and retain it
      opts["${BASH_REMATCH[1]}"]=$"${BASH_REMATCH[2]}"
    fi
    
  done < "${state['file']}"
}

function save_file {
  
  sh -c "cat > ${state['file']}" <<MYEOF

refresh_time="${opts["refresh_time"]}"

format_duration="${opts["format_duration"]}"
format_time="${opts['format_time']}"
format_date="${opts['format_date']}"
format_entry="${opts['format_entry']}"

entries:
$(
for entry in "${entries[@]}"; do
  echo "${entry}"
done
)
MYEOF

}

function trap_func {
  echo
  echo 'saving...'
  save_file
  echo 'saved!'
  exit 0
}
trap trap_func SIGINT SIGTERM


read_file

for entry in "${entries[@]}"; do
  echo "${entry}"
done

start_entry
show_curr_entry

while true; do
  update_curr_entry
  do_over
  show_curr_entry
  sleep "${opts['refresh_time']}"
done
